#!/usr/bin/env bash

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=lib/config.sh
source "$SCRIPT_DIR/lib/config.sh"

PROJECT_ROOT="$(ralph_resolve_project_root)"
ralph_load_config "$PROJECT_ROOT"

# UNATTENDED must be CLI-only, ignore env variables
UNATTENDED=0

# Hardcoded prompt paths under the V2 project layout
DESIGN_PROMPT="$PROJECT_ROOT/.ralph/prompts/design.md"
PLAN_PROMPT="$PROJECT_ROOT/.ralph/prompts/plan.md"
EXECUTE_PROMPT="$PROJECT_ROOT/.ralph/prompts/execute.md"
HANDOFF_PROMPT="$PROJECT_ROOT/.ralph/prompts/handoff.md"
PREPARE_PROMPT="$PROJECT_ROOT/.ralph/prompts/prepare.md"
BLOCKED_PROMPT="$PROJECT_ROOT/.ralph/prompts/blocked.md"
BLOCKED_DIR="$(dirname "$SPECIFICATION")/blocked"

# Default behavior flags
FREESTYLE=0
YOLO=0
RESUME_MODE=0
RESUME_SESSION=""

# CONTAINER_WORKDIR defaults to /<basename> if using container
# This will be set dynamically if --container is used without --workdir

PASS=0
RESUME_PENDING=0

trap 'exit 0' INT

print_runtime_usage_summary() {
  cat >&2 <<'EOF'
Standard runtime usage:
  ralph
  ralph --codex
  ralph --unattended
EOF
}

print_runtime_init_guidance() {
  cat >&2 <<'EOF'
Initialize a project root with:
  ralph init

Initialize a different path with:
  ralph init --project <path>
EOF
}

find_runtime_ancestor_root_for_diagnostics() {
  local current="$PROJECT_ROOT"
  local parent=""

  while :; do
    parent="$(dirname "$current")"
    if [[ "$parent" == "$current" ]]; then
      return 1
    fi
    if [[ -d "$parent/.ralph" ]]; then
      printf '%s\n' "$parent"
      return 0
    fi
    current="$parent"
  done
}

enforce_runtime_project_root() {
  local ancestor_root=""
  local home_root=""

  if [[ -d "$PROJECT_ROOT/.ralph" ]]; then
    return 0
  fi

  if [[ -d "$PROJECT_ROOT/ralph" ]]; then
    cat >&2 <<EOF
Error: legacy V1 Ralph folder detected in this directory:
  $PROJECT_ROOT/ralph

Runtime mode now requires a V2 project root with '.ralph' in the current directory.
If you intentionally want the legacy V1 flow, run:
  ./ralph/start
Otherwise migrate this project with:
  ralph upgrade
EOF
    return 1
  fi

  ancestor_root="$(find_runtime_ancestor_root_for_diagnostics || true)"

  if [[ -n "${HOME:-}" ]]; then
    home_root="$(ralph_resolve_project_root "$HOME")"
  fi

  if [[ -n "$ancestor_root" && "$ancestor_root" != "$home_root" ]]; then
    cat >&2 <<EOF
Error: Ralph must be run from the project root directory.

Current directory:
  $PROJECT_ROOT
Detected Ralph project root:
  $ancestor_root

Change to the project root and run Ralph there.
EOF
    print_runtime_usage_summary
    return 1
  fi

  if [[ -n "$home_root" && -d "$home_root/.ralph" ]]; then
    cat >&2 <<EOF
Error: Ralph runtime requires a V2 project root in the current directory.
Ralph runs a design -> plan -> execute loop for one project at a time.
No project '.ralph' directory was found in this directory or its ancestors.

Only user-level Ralph config was found at:
  $home_root/.ralph
~/.ralph stores global defaults and cannot be used as a project root.
EOF
    print_runtime_init_guidance
    print_runtime_usage_summary
    return 1
  fi

  cat >&2 <<EOF
Error: Ralph runtime requires a V2 project root in the current directory.
Ralph runs a design -> plan -> execute loop for one project at a time.
No '.ralph' directory was found in the current directory or any parent directories.
EOF
  print_runtime_init_guidance
  print_runtime_usage_summary
  return 1
}

# Parse command-line arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    -u|--unattended)
      UNATTENDED=1
      shift
      ;;
    --codex)
      USE_CODEX=1
      shift
      ;;
    --container)
      if [[ $# -lt 2 ]]; then
        echo "Error: --container requires a container name"
        exit 2
      fi
      CONTAINER_NAME="$2"
      shift 2
      ;;
    --workdir)
      if [[ $# -lt 2 ]]; then
        echo "Error: --workdir requires a path"
        exit 2
      fi
      CONTAINER_WORKDIR="$2"
      shift 2
      ;;
    --callback)
      if [[ $# -lt 2 ]]; then
        echo "Error: --callback requires a script path"
        exit 2
      fi
      CALLBACK="$2"
      shift 2
      ;;
    -f|--freestyle)
      FREESTYLE=1
      shift
      ;;
    -y|--yolo)
      YOLO=1
      shift
      ;;
    --resume)
      RESUME_MODE=1
      # Check if next arg exists and doesn't start with -
      if [[ $# -ge 2 && ! "$2" =~ ^- ]]; then
        RESUME_SESSION="$2"
        shift 2
      else
        shift
      fi
      ;;
    -h|--help)
      echo "Usage: $0 [OPTIONS]"
      echo ""
      echo "Options:"
      echo "  -u, --unattended        Full permissions; use non-interactive mode only during execute/handoff"
      echo "  -f, --freestyle         Run execute loop with prepare prompt (skip spec/plan checks)"
      echo "  -y, --yolo              Enable full permissions (interactive unless -u)"
      echo "  --codex                 Use Codex instead of Claude"
      echo "  --resume [guid]         Resume previous session (optional session ID for Claude or Codex)"
      echo "  --container <name>      Execute commands inside specified container"
      echo "  --workdir <path>        Container working directory (default: /<basename>)"
      echo "  --callback <script>     Run script after each pass"
      echo "  -h, --help              Show this help message"
      exit 0
      ;;
    *)
      echo "Error: Unknown option: $1"
      echo "Usage: $0 [OPTIONS]"
      echo "Run '$0 --help' for more information"
      exit 2
      ;;
  esac
done

if ! enforce_runtime_project_root; then
  exit 1
fi

if [[ -n "$LOG_DIR" ]]; then
  mkdir -p "$LOG_DIR"
fi

# Freestyle + unattended: downgrade to yolo (elevated permissions, still interactive)
if [[ $FREESTYLE -eq 1 && $UNATTENDED -eq 1 ]]; then
  UNATTENDED=0
  YOLO=1
fi

# Resume should only apply to the first pass of the main loop.
RESUME_PENDING=$RESUME_MODE

# Set default CONTAINER_WORKDIR if using container and not explicitly set
if [[ -n "$CONTAINER_NAME" && -z "$CONTAINER_WORKDIR" ]]; then
  BASENAME="$(basename "$(pwd)")"
  CONTAINER_WORKDIR="/$BASENAME"
fi

# Validate callback if specified
if [[ -n "$CALLBACK" ]]; then
  if ! command -v -- "$CALLBACK" >/dev/null 2>&1; then
    echo "Error: --callback not found or not executable: $CALLBACK" >&2
    exit 2
  fi
fi

# Validate container runtime if using containers
if [[ -n "$CONTAINER_NAME" ]]; then
  if ! command -v "$CONTAINER_RUNTIME" >/dev/null 2>&1; then
    echo "Error: $CONTAINER_RUNTIME not found (required for --container)" >&2
    exit 2
  fi
fi

ensure_container_running() {
  if [[ -z "$CONTAINER_NAME" ]]; then
    return 0
  fi

  local running
  running="$("$CONTAINER_RUNTIME" inspect -f '{{.State.Running}}' "$CONTAINER_NAME" 2>/dev/null)"
  if [[ -z "$running" ]]; then
    echo "Error: container not found: $CONTAINER_NAME" >&2
    exit 2
  fi
  if [[ "$running" != "true" ]]; then
    echo "Error: container is not running: $CONTAINER_NAME" >&2
    exit 2
  fi
}

container_exec() {
  "$CONTAINER_RUNTIME" exec "${CONTAINER_EXEC_FLAGS[@]}" -w "$CONTAINER_WORKDIR" "$CONTAINER_NAME" "$@"
}

set_container_exec_flags() {
  local require_tty="$1"
  if [[ "$require_tty" == "1" ]]; then
    if [[ ! -t 0 ]]; then
      echo "Error: interactive mode requires a TTY. Re-run from a real terminal or use --unattended." >&2
      exit 2
    fi
    CONTAINER_EXEC_FLAGS=(-i -t)
  else
    CONTAINER_EXEC_FLAGS=(-i)
  fi
}

set_permission_flags() {
  if [[ $YOLO -eq 1 || $UNATTENDED -eq 1 ]]; then
    PERM_CODEX_FLAGS=(--dangerously-bypass-approvals-and-sandbox)
    PERM_CLAUDE_FLAGS=(--dangerously-skip-permissions)
  else
    PERM_CODEX_FLAGS=()
    PERM_CLAUDE_FLAGS=()
  fi
}

run_noninteractive_cmd() {
  local pid
  local target_pid
  local previous_trap
  previous_trap=$(trap -p INT)

  if command -v setsid >/dev/null 2>&1; then
    setsid "$@" &
    pid=$!
    target_pid="-$pid"
  else
    "$@" &
    pid=$!
    target_pid="$pid"
    local pgid
    pgid=$(ps -o pgid= "$pid" 2>/dev/null | tr -d ' ')
    if [[ -n "$pgid" ]]; then
      target_pid="-$pgid"
    fi
  fi

  trap 'kill -INT -- "$target_pid" 2>/dev/null; sleep 1; kill -TERM -- "$target_pid" 2>/dev/null; sleep 1; kill -KILL -- "$target_pid" 2>/dev/null; exit 130' INT
  wait "$pid"
  local status=$?

  if [[ -n "$previous_trap" ]]; then
    eval "$previous_trap"
  else
    trap - INT
  fi

  return $status
}

run_codex() {
  local noninteractive="$1"
  local prompt_text="$2"

  local codex_cmd=(codex "${PERM_CODEX_FLAGS[@]}")
  if [[ $RESUME_PENDING -eq 1 ]]; then
    if [[ "$noninteractive" == "1" ]]; then
      codex_cmd+=(exec resume)
      if [[ -n "$RESUME_SESSION" ]]; then
        codex_cmd+=("$RESUME_SESSION")
      else
        codex_cmd+=(--last)
      fi
      codex_cmd+=(continue)
    else
      codex_cmd+=(resume)
      if [[ -n "$RESUME_SESSION" ]]; then
        codex_cmd+=("$RESUME_SESSION")
      else
        codex_cmd+=(--last)
      fi
    fi
  else
    if [[ "$noninteractive" == "1" ]]; then
      codex_cmd+=(exec "$prompt_text")
    else
      codex_cmd+=("$prompt_text")
    fi
  fi

  if [[ -n "$CONTAINER_NAME" ]]; then
    set_container_exec_flags "$([[ "$noninteractive" == "1" ]] && echo 0 || echo 1)"
    if [[ "$noninteractive" == "1" ]]; then
      run_noninteractive_cmd "$CONTAINER_RUNTIME" exec "${CONTAINER_EXEC_FLAGS[@]}" -w "$CONTAINER_WORKDIR" "$CONTAINER_NAME" "${codex_cmd[@]}"
    else
      container_exec bash -c 'trap "exit 130" INT; exec "$@"' _ "${codex_cmd[@]}"
    fi
  else
    if [[ "$noninteractive" == "1" ]]; then
      run_noninteractive_cmd "${codex_cmd[@]}"
    else
      bash -c 'trap "exit 130" INT; exec "$@"' _ "${codex_cmd[@]}"
    fi
  fi
}

run_claude() {
  local noninteractive="$1"
  local prompt_text="$2"

  local claude_cmd=(claude "${PERM_CLAUDE_FLAGS[@]}")

  if [[ $RESUME_PENDING -eq 1 ]]; then
    if [[ -n "$RESUME_SESSION" ]]; then
      claude_cmd+=(--resume "$RESUME_SESSION")
    else
      claude_cmd+=(--continue)
    fi
    if [[ "$noninteractive" == "1" ]]; then
      claude_cmd+=(-p continue)
    fi
  else
    if [[ "$noninteractive" == "1" ]]; then
      claude_cmd+=(-p "$prompt_text")
    else
      claude_cmd+=("$prompt_text")
    fi
  fi

  if [[ -n "$CONTAINER_NAME" ]]; then
    set_container_exec_flags "$([[ "$noninteractive" == "1" ]] && echo 0 || echo 1)"
    if [[ "$noninteractive" == "1" ]]; then
      run_noninteractive_cmd "$CONTAINER_RUNTIME" exec "${CONTAINER_EXEC_FLAGS[@]}" -w "$CONTAINER_WORKDIR" "$CONTAINER_NAME" "${claude_cmd[@]}"
    else
      container_exec bash -c 'trap "exit 130" INT; exec "$@"' _ "${claude_cmd[@]}"
    fi
  else
    if [[ "$noninteractive" == "1" ]]; then
      run_noninteractive_cmd "${claude_cmd[@]}"
    else
      bash -c 'trap "exit 130" INT; exec "$@"' _ "${claude_cmd[@]}"
    fi
  fi
}

# Main loop - iterate through workflow phases
while :; do
  PASS=$((PASS + 1))
  PROMPT="$DESIGN_PROMPT"
  EXECUTE_MODE=0
  BLOCKED_MODE=0

  # Notify user when entering unattended mode
  if [[ $UNATTENDED -eq 1 ]]; then
    echo "--------"
    echo "Entering unattended execution loop.  See logs for details"
  fi

  # Check for freestyle mode first since it overrides normal phase checks
  if [[ $FREESTYLE -eq 1 ]]; then
    PROMPT="$PREPARE_PROMPT"
    EXECUTE_MODE=1
  else
    # Determine which phase we're in based on planning documents
    if [[ -f "$SPECIFICATION" && -f "$EXECUTION_PLAN" ]]; then
      PROMPT="$EXECUTE_PROMPT"
      EXECUTE_MODE=1
    elif [[ -f "$SPECIFICATION" ]]; then
      PROMPT="$PLAN_PROMPT"
    elif [[ -f "$EXECUTION_PLAN" ]]; then
      echo "Error: $EXECUTION_PLAN exists but $SPECIFICATION is missing."
      exit 1
    else
      # Neither planning document exists - check if blocked before entering design mode
      if [[ -f "$BLOCKED_DIR/SPECIFICATION.md" || -f "$BLOCKED_DIR/EXECUTION_PLAN.md" ]]; then
        PROMPT="$BLOCKED_PROMPT"
        BLOCKED_MODE=1
      fi
    fi
  fi

  set_permission_flags
  if [[ $EXECUTE_MODE -eq 1 && $UNATTENDED -eq 1 ]]; then
    NONINTERACTIVE=1
  else
    NONINTERACTIVE=0
  fi

  # Validate prompt file exists and provide helpful error message
  if [[ ! -f "$PROMPT" ]]; then
    echo "Error: Prompt file not found: $PROMPT"
    echo ""
    echo "Prompts are project-specific and must be customized for your project."
    echo "Copy from the example template(s):"
    echo ""
    missing_any=0
    if [[ ! -f "$DESIGN_PROMPT" ]]; then
      echo "  cp \"$SCRIPT_DIR/prompts/design.example.md\" \"$DESIGN_PROMPT\""
      missing_any=1
    fi
    if [[ ! -f "$PLAN_PROMPT" ]]; then
      echo "  cp \"$SCRIPT_DIR/prompts/plan.example.md\" \"$PLAN_PROMPT\""
      missing_any=1
    fi
    if [[ ! -f "$EXECUTE_PROMPT" ]]; then
      echo "  cp \"$SCRIPT_DIR/prompts/execute.example.md\" \"$EXECUTE_PROMPT\""
      missing_any=1
    fi
    if [[ ! -f "$PREPARE_PROMPT" ]]; then
      echo "  cp \"$SCRIPT_DIR/prompts/prepare.example.md\" \"$PREPARE_PROMPT\""
      missing_any=1
    fi
    if [[ ! -f "$HANDOFF_PROMPT" ]]; then
      echo "  cp \"$SCRIPT_DIR/prompts/handoff.example.md\" \"$HANDOFF_PROMPT\""
      missing_any=1
    fi
    if [[ ! -f "$BLOCKED_PROMPT" ]]; then
      echo "  cp \"$SCRIPT_DIR/prompts/blocked.example.md\" \"$BLOCKED_PROMPT\""
      missing_any=1
    fi
    if [[ $missing_any -eq 0 ]]; then
      echo "  (all prompt files are present)"
    fi
    echo ""
    echo "Then edit the prompt to reference your project's documentation."
    exit 1
  fi

  ensure_container_running
  prompt_text="$(cat "$PROMPT")"
  if [[ $NONINTERACTIVE -eq 1 ]]; then
    error_offset=0
    output_offset=0
    if [[ -f "$ERROR_LOG" ]]; then
      error_offset=$(wc -c < "$ERROR_LOG")
    fi
    if [[ -f "$OUTPUT_LOG" ]]; then
      output_offset=$(wc -c < "$OUTPUT_LOG")
    fi
    {
      printf '\n---\n\nPass %d:\n' "$PASS"
      if [[ $USE_CODEX -eq 1 ]]; then
        run_codex 1 "$prompt_text"
      else
        run_claude 1 "$prompt_text"
      fi
    } >> "$OUTPUT_LOG" 2> "$ERROR_LOG"
  else
    if [[ $USE_CODEX -eq 1 ]]; then
      run_codex 0 "$prompt_text" 2> "$ERROR_LOG"
    else
      run_claude 0 "$prompt_text" 2> "$ERROR_LOG"
    fi
  fi
  status=$?
  RESUME_PENDING=0
  if [[ $NONINTERACTIVE -eq 1 && -f "$ERROR_LOG" ]]; then
    if tail -c "+$((error_offset + 1))" "$ERROR_LOG" | grep -qi "task interrupted"; then
      exit 0
    fi
  fi
  if [[ $NONINTERACTIVE -eq 1 && -f "$OUTPUT_LOG" ]]; then
    if tail -c "+$((output_offset + 1))" "$OUTPUT_LOG" | grep -qi "task interrupted"; then
      exit 0
    fi
  fi
  if [[ $status -eq 130 ]]; then
    exit 0
  fi

  if [[ $status -ne 0 ]]; then
    if [[ $USE_CODEX -eq 1 ]]; then
      echo "Codex exited with status $status"
    else
      echo "Claude exited with status $status"
    fi
    cat "$ERROR_LOG"
    exit 1
  fi

  # Run handoff only for non-freestyle execute passes when both planning docs still exist.
  if [[ $EXECUTE_MODE -eq 1 && $FREESTYLE -eq 0 ]]; then
    if [[ -f "$SPECIFICATION" && -f "$EXECUTION_PLAN" ]]; then
      if [[ -f "$HANDOFF_PROMPT" ]]; then
        handoff_text="$(cat "$HANDOFF_PROMPT")"
        handoff_require_tty=1
        if [[ $UNATTENDED -eq 1 ]]; then
          handoff_require_tty=0
        fi

        if [[ $UNATTENDED -eq 1 ]]; then
          {
            echo ""
            echo "----------------"
            echo "Running handoff..."
            if [[ $USE_CODEX -eq 1 ]]; then
              codex_session_id=""
              if [[ -f "$ERROR_LOG" ]]; then
                codex_session_id="$(
                  awk -F 'session id:' '/session id:/ {id=$2} END {gsub(/^[[:space:]]+|[[:space:]]+$/,"",id); print id}' "$ERROR_LOG"
                )"
              fi
              handoff_codex_flags=("${PERM_CODEX_FLAGS[@]}")
              if [[ -n "$CONTAINER_NAME" ]]; then
                set_container_exec_flags "$handoff_require_tty"
                if [[ -n "$codex_session_id" ]]; then
                  container_exec codex "${handoff_codex_flags[@]}" exec resume "$codex_session_id" "$handoff_text" || echo "Warning: Handoff failed (non-fatal)"
                else
                  container_exec codex "${handoff_codex_flags[@]}" exec resume --last "$handoff_text" || echo "Warning: Handoff failed (non-fatal)"
                fi
              else
                if [[ -n "$codex_session_id" ]]; then
                  codex "${handoff_codex_flags[@]}" exec resume "$codex_session_id" "$handoff_text" || echo "Warning: Handoff failed (non-fatal)"
                else
                  codex "${handoff_codex_flags[@]}" exec resume --last "$handoff_text" || echo "Warning: Handoff failed (non-fatal)"
                fi
              fi
            else
              handoff_claude_flags=("${PERM_CLAUDE_FLAGS[@]}")
              if [[ -n "$CONTAINER_NAME" ]]; then
                set_container_exec_flags "$handoff_require_tty"
                container_exec claude "${handoff_claude_flags[@]}" --continue "$handoff_text" || echo "Warning: Handoff failed (non-fatal)"
              else
                claude "${handoff_claude_flags[@]}" --continue "$handoff_text" || echo "Warning: Handoff failed (non-fatal)"
              fi
            fi
          } >> "$OUTPUT_LOG" 2> "$ERROR_LOG"
        else
          echo "Running handoff..."
          if [[ $USE_CODEX -eq 1 ]]; then
            codex_session_id=""
            if [[ -f "$ERROR_LOG" ]]; then
              codex_session_id="$(
                awk -F 'session id:' '/session id:/ {id=$2} END {gsub(/^[[:space:]]+|[[:space:]]+$/,"",id); print id}' "$ERROR_LOG"
              )"
            fi
            handoff_codex_flags=("${PERM_CODEX_FLAGS[@]}")
            handoff_status=0
            error_offset=0
            if [[ -f "$ERROR_LOG" ]]; then
              error_offset=$(wc -c < "$ERROR_LOG")
            fi
            if [[ -n "$CONTAINER_NAME" ]]; then
              set_container_exec_flags "$handoff_require_tty"
              if [[ -n "$codex_session_id" ]]; then
                run_noninteractive_cmd "$CONTAINER_RUNTIME" exec "${CONTAINER_EXEC_FLAGS[@]}" -w "$CONTAINER_WORKDIR" "$CONTAINER_NAME" codex "${handoff_codex_flags[@]}" exec resume "$codex_session_id" "$handoff_text" 2> >(tee -a "$ERROR_LOG" >&2)
              else
                run_noninteractive_cmd "$CONTAINER_RUNTIME" exec "${CONTAINER_EXEC_FLAGS[@]}" -w "$CONTAINER_WORKDIR" "$CONTAINER_NAME" codex "${handoff_codex_flags[@]}" exec resume --last "$handoff_text" 2> >(tee -a "$ERROR_LOG" >&2)
              fi
            else
              if [[ -n "$codex_session_id" ]]; then
                run_noninteractive_cmd codex "${handoff_codex_flags[@]}" exec resume "$codex_session_id" "$handoff_text" 2> >(tee -a "$ERROR_LOG" >&2)
              else
                run_noninteractive_cmd codex "${handoff_codex_flags[@]}" exec resume --last "$handoff_text" 2> >(tee -a "$ERROR_LOG" >&2)
              fi
            fi
            handoff_status=$?
            stty sane 2>/dev/null  # Reset terminal in case codex left it in bad state
            echo "DEBUG: codex exited with status $handoff_status" >&2
            if [[ -f "$ERROR_LOG" ]]; then
              if tail -c "+$((error_offset + 1))" "$ERROR_LOG" | grep -q "task interrupted"; then
                exit 0
              fi
            fi
            if [[ $handoff_status -ne 0 ]]; then
              exit 0  # Exit cleanly on any non-zero (including SIGINT)
            fi
          else
            handoff_claude_flags=("${PERM_CLAUDE_FLAGS[@]}")
            if [[ -n "$CONTAINER_NAME" ]]; then
              set_container_exec_flags "$handoff_require_tty"
              container_exec claude "${handoff_claude_flags[@]}" --continue "$handoff_text" 2>&1 || echo "Warning: Handoff failed (non-fatal)"
            else
              claude "${handoff_claude_flags[@]}" --continue "$handoff_text" 2>&1 || echo "Warning: Handoff failed (non-fatal)"
            fi
          fi
        fi
      fi
    fi
  fi

  # run callback if specified
  if [[ -n "$CALLBACK" ]]; then
    if ! "$CALLBACK"; then
      echo "Callback failed: $CALLBACK" >&2
      exit 1
    fi
  fi
done
